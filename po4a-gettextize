#! /usr/bin/perl
eval 'exec /usr/bin/perl -S $0 ${1+"$@"}'
    if $running_under_some_shell;

# po4a-gettextize -- Convert an original file to a po file
# $Id: po4a-gettextize,v 1.16 2004-04-28 09:01:10 mquinson-guest Exp $
#
# Copyright 2002, 2003, 2004 by Martin Quinson <Martin.Quinson@ens-lyon.fr>
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of GPL (see COPYING).

my $VERSION=$Locale::Po4a::TransTractor::VERSION;

=head1 NAME

po4a-gettextize - Convert an original file (and its translation) to a po file

=head1 SYNOPSIS

po4a-gettextize -f E<lt>formatE<gt> -m E<lt>master.docE<gt> [-l E<lt>localized.docE<gt>] -p E<lt>translation.poE<gt>

=head1 DESCRIPTION

The po4a (po for anything) project goal is to ease translations (and more
interstingly, the maintenance of translation) using gettext tools on areas
where they were not expected like documentation.

The C<po4a-gettextize> script is in charge of converting documentation
files to po files.  If you start a new translation, C<po4a-gettextize>
will extract the translatable strings from the documentation file and
write a pot file from it.

If you already have a translated file, C<po4a-gettextize> will try to
extract the translations it contains and put them in place in the written
po file. Be warned that very few intelligence is used in this process: the
Nth string of the translated file is supposed to be the translation of the
Nth string in the original. If it's not the case, you're dead. That's why
it is very important that both file share exactly the same structure.

However, C<po4a-gettextize> will diagnose your death by detecting any
desyncronisation between files, and repporting where they occur. In that
case, you should edit manually the files to solve the repported
disparity. Even if no error were repported, you check carefully that the
generated po file is correct (ie, that each msgstr is the translation of
the associated msgid, and not the one before or after).

Even if the script manage to do its job without apparent problems, it still
mark all extracted translation as fuzzy, to make sure that the translator
will have a look at them, and detect any remaining problem.

=head1 OPTIONS

=over 4

=item -f, --format

Format type of the documentation you want to handle. Use the --help-format
option to see the list of available formats.

=item -m, --master

File containing the master document to translate.

=item -M, --master-charset

Charset of the file containing the document to translate.

=item -l, --localized

File containing the localized (translated) document.

=item -L, --localized-charset

Charset of the file containing the localized document.

=item -p, --po

File where the message catalog should be written. If not given, the message
catalog will be written to the standard output.

=item -o, --option

Pass an extra option to the format plugin. See the documentation of each
plugin for more information about the valid options and their meaning.

=item -h, --help

Show a short help message.

=item --help-format

List the documentation format understood by po4a.

=item -V, --version

Displays the version of the script and exits.

=item -v, --verbose

Increase the verbosity of the program.

=item -d, --debug

Outputs some debugging informations.

=back

=head1 SEE ALSO

L<po4a(7)>, L<po4a-updatepo(1)>, L<po4a-translate(1)>, L<po4a-normalize(1)>.

=head1 AUTHORS

 Denis Barbier <barbier@linuxfr.org>
 Martin Quinson <martin.quinson@tuxfamily.org>

=head1 COPYRIGHT AND LICENSE

Copyright 2002, 2003, 2004 by SPI, inc.

This program is free software; you may redistribute it and/or modify it
under the terms of GPL (see COPYING file).

=cut

use 5.006;
use strict;
use warnings;

use Getopt::Long qw(GetOptions);

use Locale::Po4a::Chooser;

use Pod::Usage qw(pod2usage);

use Locale::gettext;
use POSIX;     # Needed for setlocale()

setlocale(LC_MESSAGES, "");
textdomain('po4a');


sub show_version {
    print sprintf(gettext("%s version %s.\nwritten by Martin Quinson and Denis Barbier.\n\nCopyright (C) 2002, 2003, 2004 Software of Public Interest, Inc.\nThis is free software; see source code for copying\nconditions. There is NO warranty; not even for \nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n"),$"po4a-gettextize",VERSION);
}

my ($pofile)=('-');
my ($masterfile,$locfile,$help_fmt,$help,$type,$debug,$verbose,@options);
Getopt::Long::config('bundling', 'no_getopt_compat', 'no_auto_abbrev');
GetOptions(
        'help|h'        => \$help,
	'help-format'   => \$help_fmt,
        
        'master|m=s'    => \$masterfile,
	'localized|l=s' => \$locfile,
        'po|p=s'        => \$pofile,
        'format|f=s'    => \$type,

        'option|o=s'    => \@options,
    
        'verbose|v'     => \$verbose,
        'debug|d'       => \$debug,
        'version|V'     => \&show_version
) or pod2usage(1);

# Argument check
$help && pod2usage (0);
$help_fmt && Locale::Po4a::Chooser::list(0);
pod2usage (1) if (scalar @ARGV > 1) || 
    (!defined($masterfile)) || (!length($masterfile));

my %options = (
    "verbose" => $verbose,
    "debug" => $debug);

foreach (@options) {
    if (m/^([^=]*)=(.*)$/) {
	$options{$1}="$2";
    } else {
	$options{$_}=1;
    }
}
# Check file existence
-e $masterfile || die sprintf(gettext("File %s does not exists.\n"),$masterfile);
if (defined $locfile && length($locfile)) {
    -e $locfile || die sprintf(gettext("File %s does not exists.\n"),$locfile);
}

# Declare the TransTractor parsers
my ($mastertt,$transtt)=(Locale::Po4a::Chooser::new($type,%options),
			 Locale::Po4a::Chooser::new($type,%options));

# Parse master file
$mastertt->read($masterfile);
$mastertt->parse;


unless (defined ($locfile) && length($locfile)) {
  # Ok, outputing the pot extracted from original is enough
  $mastertt->writepo($pofile);
} else {
  # We have to merge two transtractor files

  $transtt->read($locfile);
  $transtt->parse;

  my $mergedpo = Locale::Po4a::Po->gettextize($mastertt->getpoout(),
                                              $transtt->getpoout());

  $mergedpo->write($pofile);
}
  
__END__
