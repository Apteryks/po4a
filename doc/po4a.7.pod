=head1 NAME

po4a - framework to translate documentation and other material

=head1 DESCRIPTION

The po4a (po for anything) project goal is to ease translations (and more
interestingly, the maintainance of translations) using gettext tools on areas
where they were not expected like documentation.

In po4a each documentation format is handled by a module. For now, we have
a module for the pod format (in which the perl documentation is written),
the good old man pages, and the documentation of the kernel compilation
options. Some other modules are underway, like for sgml, xml or texinfo.

=head1 Table of content

This documentation is organized as follow:

=over

=item 1 How to use po4a?

This first section is a sort of reference manual, trying to answer the
users' questions. It tries to explain HOW TO do things with po4a.

=item 2 How does it work?

This section gives you a brief overview of the po4a internals, so that you
may feel more confident to help us maintaining and improving it. It also
helps you understanding why it does not do what you expected, and how to
solve your problems.

=item 3 FAQ

This section groups the Frequently Asked Questions. In fact, most of the
questions for now could be formulated that way: "Why is it designed that
way, and not..." If you think po4a isn't the right answer to documentation
translation, read this section.

=item 4 Specific notes about modules

This section presents the specificities of each modules from the translator
and original author point of view. Read this to learn the syntax you will
encounter when translating stuff in this module, or the rules you should
follow in your original document to make translators' life easier.

FIXME: This section isn't written yet. This text is for now in the manpage
of each module.

=item 5 Known bugs and feature requests

Quite a few already :(

=back

=head1 How to use po4a?

This first section is a sort of reference manual, trying to answer the
users' questions. It tries to explain HOW TO do things with po4a.

=head2 How to begin a new translation?

To begin a new translation using po4a, you have to do the following steps:

=over 2

=item -

Make a new pot file, representing the text which have to be translated under
the gettext format. For that, use the I<po4a-gettextize> program like that:

  $ po4a-gettextize -f <format> -m <master.doc> -p <translation.pot>

Please refer to L<po4a-translate(1)> for more details, like the list of
existing modules (which is also documented elsewhere in this document)

=item -

Actually translate what should be translated. For that, you have to rename
the pot file to XX.po (where XX is the ISO639 code of the language you are
translating to, e.g. "fr" for French), and edit the resulting file. 

To achieve this task, you may find useful to use the Emacs po mode, or
kbabel (KDE based) or gtranslator (GNOME based).

If you need more information about this task, you definitively need to
refer to the gettext documentation, available in the B<gettext-doc>
package.

=back

=head2 How do I convert back the translation to a documentation file?

Once you have an up-to-date and completely translated po file, you need to
convert it to an up-to-date and completely translated documentation file,
so that you can distribute it to users.

For that, use the I<po4a-translate> program like that (where XX is the
language code):

  $ po4a-translate -f <format> -m <master.sgml> -p <XX.po> -l <XX.sgml>

Please refer to L<po4a-translate(1)> for more details.

=head2 What do I do when the original file has changed?

Documentation often evolves, and things become complicated when the
original author changes the English document. To update your translation
when the original file has changed, use the I<po4a-updatepo> program like that:

  $ po4a-updatepo -f <format> -m new_original.file -p existing.XX.po

(Please refer to L<po4a-updatepo(1)> for more details)

Naturally, the new paragraph in the document won't get magically translated
in the C<po> file with this operation, and you'll need to update the C<po>
file manually. Likewise, you may have to rework the translation for
paragraphs which were modified a bit (to make sure you won't miss any of
them, they are marked as "fuzzy" during the process).

So, you have to update manually the resulting C<po> file using your
favorite po editor. Make sure all strings are translated, and that you
removed all the fuzzy marks (after reviewing the corresponding
translations). 

Once your C<po> file is up-to-date again, without any untranslated or fuzzy
string left, you can generate a translated documentation file, as explained
in the previous section.


=head2 How to convert a previously existing translation to this system?

Often, you used to translate manually the document happily until a major
reorganization of the original document happened. When it happens, you want
to convert to po4a, but you don't want to redo your translation from
scratch. Don't worry, this case is also handled by po4a tools and is
called gettextization. Be warned that this operation is a bit more error
prone than the rest, and you should check carefully the result.

For more information about this conversion and how it works, check the
section I<Gettextization: how does it work?> below.

To ease the writing (and the comprehension) of this section, we consider
converting a translation of SGML document, but this is exactly the same for
all modules. Only file names and the C<-f> option change.

=over 2	

=item -

First, you have to get the original.sgml you used to do your translation. It
has to have exactly the same content as your translation. That is to say
that if you translated the cvs version 1.34 of the original, and you want to
use po4a to translate version 1.124, B<you have to use the version
1.34 of the original here>, not version 1.124. You may even have to manually
edit both the original and the translation so that they have exactly the
same structure (the programs will help you in this task). 

=item -

Then, remove every part you added in the translation and which was not in
the original document. For example, if you added your name to the authors'
list, you need to remove that. Likewise, remove all the extra chapters you
added (such as "about this translation"). Don't worry, you'll be able to
add them again afterward (see section I<How to add stuff which is not a
translation (like translator's name)?> below).

=item -

Generate a completely translated, B<but not up-to-date> C<po> file from
your XX.sgml translation and the original.old.sgml files using the
following command:

 $ po4a-gettextize -f sgml -m original.old.sgml -l XX.sgml -p XX.po

If the translated and the original files don't have the exact same
structure, this command will fail. In that case, you need to edit them to
correct the problem. See the section I<Gettextization: how does it work?>
below to see why this is needed.

When possible, edit the translated document and not the original one,
because if you change the original, you won't be able to reuse the
translation you made for future version of the original document (which
will use the unmodified sentences). But if you need to, go ahead and change
the original. You need to get this damned gettextization done.

Note that the generated po file will have all entries marked as fuzzy. This
is because the gettextization process may be error prone, and because it
would be a bad idea to trust it completely. That way, we are sure that
translators will check the result of the gettextization before using the
translation obtained.

=back

After this difficult step, you successfully converted your translation to
the po4a system. The next step will be to update your work to the current
version of the original document, from version 1.34 to version 1.124 in our
previous example. This is explained in the section I<What do I do when the
original file has changed?> above.

=head2 How to add stuff which is not a translation (like translator's name)?

This one of the major headache for po-based documentation translation
systems. In po4a, the solution is called addendum.

Addendum can be seen as post-processing patches to the produced
document. They allow the translator to add original content to the document
which is not translated from the original document. This way, they can add
a section giving the name of the contributors to this translation, or
explain how to report bug against the translation.

Addendum must be provided to the system as a file, with the first line
indicating where in the produced document they should be placed in a so
called Po4a header. The rest of the addendum file with be added verbatim in
the resulting document.

The header have a pretty rigid syntax: They must begin with "PO4A-HEADER:",
followed by a semi-colon (;) separated list of fields, each of them having the
"key=value" syntax. White spaces ARE important. Note that you cannot use the
semi-colon char (;) in the value, and that quoting it doesn't help. The
recognized keys are:

=over 4

=item position (mandatory)

a regexp. The addendum will be placed near the line matching this
regexp. Note that we're speaking about the translated document here, not
the original. If more than a line match this expression (or none),
the addition will fail since we don't know were to put it.

This line is called I<position point> in the following. The point
were the addendum will be added is called I<insertion point>. Those two
points are near one from another, but not identique, due to the C<mode>,
C<beginboundary> and C<endboundary> arguments. See below.


=item mode (mandatory)

can be "before" or "after", specifying the position of the addendum,
relative to the I<position point>.

=item beginboundary (usefull only when mode=after, and mandatory in that case)

=item endboundary

regexp matching the end of the section after which we should put the
addendum.

When mode=after, the I<insertion point> is after the I<position point>, but
not directly after! It is placed at the end of the section beginning at the
I<position point>, ie after or before the line matched by the
C<***boundary> argument, depending on whether you used C<beginboundary> or
C<endboundary>.

Both arguments exists because documentation formats are differents. In some
of them, there is a way to mark the end of a section (think about
C<E<lt>/sectionE<gt>> in sgml), while some other don't mark the end of
section (like in nroff). In the former case, you want to make a I<boundary>
matching the I<end of a section>, so that the I<insertion point> comes after
it. In the latter case, you want to make a I<boundary> matching the
I<begining of next section>, so that the I<insertion point> comes just
before it. This can seem obscure, but hopefully, the next exemples will
enlighten you.

For example, if you want to add something after the following sgml section:

  <sect1><header>AUTHORS</header>

you should put a C<position> matching this line, and an C<endboundary>
matching the end of a section (ie C<E<lt>/sect1E<gt>>). The addendum will
then be added B<after> the I<position point> and immediatly B<after> the
first line matching the C<endboundary>.

If you want to add something after the following nroff section:

  .SH "AUTHORS"

you should put a C<position> matching this line, and an C<beginboundary>
matching the begining of the next section (ie C<^\.SH>). The addendum will
then be added B<after> the I<position point> and immediatly B<before> the
first line matching the C<beginboundary>.

If you want to add something just after a given line of your translated
document, (say "Copyright blabla"), give a C<position> matching this line
(ie, C<Copyright blabla>), and give a C<beginboundary> matching anything (ie
C<^>).

If you want to add something at the end of the document, give a C<position>
matching any line of your document (but only one line, because po4a will
refuse to process your addendum if there is more than one possible position
point), and give an C<endboundary> matching nothing. Don't use simple regexp
here like C<EOF>, but prefere a long string for which you are sure that it
won't be in your document. C<DummyPo4aBoundaryWhichWontMatchAnything> is a
pretty good example.


In any case, remember that these are regexp. For example, if you want to
match the end of a nroff section ending with the line 

  .fi

don't use C<.fi> as endboundary, because it will match with "the[ fi]le",
which is obviously not what you expect. The correct endboundary in that case
is: C<^\.fi$>

If the addenda don't go where you expected, try to pass the -v argument to
po4a-translate, so that it explains you what it does while placing the
addendum.

=item lang

language code for which we have to use this insert (NOT USED SO FAR).

=back

Here are some example of headers. The first one present the mode=before,
which is pretty simple to use, while the others present the infamous
mode=after, and the two type of boundaries. In sgml, endboundary are useful
(since they will work even in case of document reorganization), but in pod
or man, beginboundary are easier to use (since there is no ending tag
here):

 PO4A-HEADER:mode=before;position=AUTHORS

 PO4A-HEADER:mode=after;endboundary=</sect1>;position=AUTHORS

 PO4A-HEADER:mode=after;beginboundary=^=head1;position=AUTHORS
 PO4A-HEADER:mode=after;beginboundary=\.SH;position=AUTHORS

=head3 Example 1

If you have the following original pod file:

 |=head1 NAME
 |
 |dummy - a dummy program
 |
 |=head1 AUTHOR
 |
 |me

and a file named C<extra-content> contains this:

 |PO4A-HEADER:mode=after;position=AUTEUR;lang=fr;beginboundary=^head
 |
 |=head1 TRADUCTEUR
 |
 |moi

passing the C<--add-file extra-content> argument to pod-translate will add
a section (in French) about the translator at the end of the file. (This
example is in French ; "TRADUCTEUR" means "TRANSLATOR", and "moi" means
"me")

=head3 Example 2

To put the addendum before the AUTHORS, you could use the following header:

 PO4A-HEADER:mode=after;section=NOM;lang=fr;beginboundary=^head1

because after the section "NAME" (translated to "NOM" in French), the next
line matching the beginboundary /^head1/ is the one declaring the authors. So,
the addendum will be put between both sections.

=head2 Graphical summary

In the following schema, you will find a summary of all programs, files and
operations involved in po4a. Do not be afraid by its apparent complexity,
it comes from the fact that the I<whole> system is represented here. Once
you converted your project to po4a, only the bottom right part of the
graphic is relevant (i.e., I<po4a-updatepo>, manual editing and
I<po4a-translate> ). Once again, sgml is taken as example, but the same
remains true for all modules.

  fr.sgml  original.sgml ---->--------+------>----------->-------+	   
     |         |                      |                          |	   
     V         V           { update of original }                |	   
     |         |                      |                          | 
     +--<---<--+                      V                          |
     |         |              original.new.sgml----->------->----+	   
     V         V                      |                          |	   
  [po4a-gettextize]      +--->---->---+                          |	   
     |         |         |            V                          |	   
     |         |         |     [po4a-updatepo]                   |	   
     |         V         ^            |                          V	   
     V    original.pot   |            V                          |	   
     |         |         |          fr.po                        |	   
     |         |         |         (fuzzy)                       |	   
     |  { translation }  |            |                          |	   
     |         |         ^            V                          V	   
     |         |         |     {manual editing}                  |	   
     V         V         |            |                          |	   
     |         |         |            V                          V	   
     |         |         +--<---    fr.po       addendum   original.sgml
     +---->----+---->------->---> (up-to-date) (optional)  (up-to-date) 
                                      |            |             |	   
                                      v            v             v
                                      +------>-----+------<------+
                                                   |
                                                   v
                                           [po4a-translate]
                                                   |
                                                   V
                                                fr.sgml
                                             (up-to-date)

=head1 How does it work?

This section gives you a brief overview of the po4a internals, so that you
may feel more confident to help us maintaining and improving it. It also
helps you understanding why it does not do what you expected, and how to
solve your problems.

=head2 What's the big picture here?

To understand the philosophy of po4a, you should check the TransTractor.pm
module, which is the ancestor class for all format parsers in
po4a. L<Locale::Po4a::TransTractor(3pm)|Locale::Po4a::TransTractor(3pm)>
presents its internals, and how to derive this class to build your own
parser.

=head2 Gettextization: how does it work?

The idea here is to take the original document and its translation, and to
say that the Nth extracted string from the translation is the translation
of the Nth extracted string from the original. In order to work, both files
must share exactly the same structure. For example, if the files have the
following structure, it is very unlikely that the 4th string in translation
(of type 'chapter') is the translation of the 4th string in original (of
type 'paragraph').

    Original         Translation

  chapter            chapter
    paragraph          paragraph
    paragraph          paragraph
    paragraph        chapter
  chapter              paragraph
    paragraph          paragraph

For that, po4a parsers are used on both the original and the translation
files to extract po files, and then another po file is builded from them
taking strings from the latter as translation of strings from the
former. In order to check that the strings we put together are actually the
translations of each other, all document parsers in po4a put informations
about the syntaxical type of extracted strings in the document. Then, this
information is used to make sure that both document have the same
syntax. In the previous example, it would allow use to detect that string 4
is a paragraph in one case, and a chapter title in another case and to
report the problem.

In theory, it would be possible to detect the problem, and resynchronize the
files after them (just like diff does), but what we should do of the few
strings before desynchronizations is not clear, and it would produce bad
results some times. That's why the current implementation don't try to
resynchronize anything and verbosely fail when something goes wrong,
requiring manual modification of files to fix the problem.

Even with these precautions, things can go wrong very easily here. That's
why all translations guessed this way are marked fuzzy to make sure that
the translator review and check them.

=head2 Addendum: How does it work?

Well, that's pretty easy here. The translated document is not written
directly to disk, but kept in memory until all addendum are applied. The
algorithms involved here are very easy. We look for a line matching the
position regexp, and insert the addendum before it if we're in
mode=before. If not, we search for the next line matching the boundary and
insert the addendum after this line if it's an C<endboundary> or before this
line if it's an C<beginboundary>.

=head1 FAQ 

This section groups the Frequently Asked Questions. In fact, most of the
questions for now could be formulated that way: "Why is it designed that
way, and not..." If you think po4a isn't the right answer to documentation
translation, read this section.

=head2 Why to translate each paragraph separately?

Yes, in po4a, each paragraphs are translated separately (in fact, each
module decides this, but all existing modules do like that). There is two
main advantages to this approach:

=over 2

=item *

When the technical parts of the document are hidden from the scene, the
translator can't mess with them. The less markers we present to the
translator the less error he can do.

=item *

Cutting the document helps in isolating the changes to the original
document. When the original is modified, finding what parts of the
translation need to be updated is eased by this process.

Of course, diff can help you in this process, but that's not always
sufficient. What to do when the original document were completely
reorganized, with some sections moving around? How to detect the changes
done during the process?

=back

Even with these advantages, some people don't like the idea of translating
each paragraphs separately. Here are some of the answers I can give to
their fear:

=over 2

=item *

First of all, the KDE project use a po-based approach for its documentation
since quite a long time, and as far as I can tell, these documents count
between the better translated ones over the free software world...

=item *

Then, it is not true to say that cutting the document in paragraph prevent
translators from using the context to understand it. Remember that the
strings in the po file are in the same order than in the original document.
So, to get the context, just read (and translate) all strings in the given
order.

Moreover, when I have to translate a big document, I first convert it to
PostScript, print it and then read it. I wouldn't claim that I use the
source code to get any global understanding of the text. XML, Sgml and Nroff
are not really readable, IMHO. 

=item *

Finally, this approach is the one used by professional translators (Ok,
that's not a definitive argument, since the goals of professional	
translators are quite different from the ones of the free translators.
Translation maintainance is for example less critical in professional
world, as the content change less often).

=back

=head2 Why not to split on sentence level (or smaller)?

In the previous section, I tried to convince you that splitting the
document is a good choice. But, could you argue, why not to split at a
still smaller grain? Why not to translate each sentence separately, or even
parts of sentences?

I said that professional translator tools often split the document at the
paragraph level, or even at the sentence level. In my opinion, this is
because professional translators sometimes want to maximize the quantity
of translation (over quality?). That's why they heavily use what they call
"translation memory" (in the gettext world, this is called
"compendium"). This is a list of well known original sentences, with their
associated translation, so that the previously translated element don't
have to be retranslated. To maximize the reusability of translations, you
have to split the text at the sentence level, and not at the paragraph or
even bigger. The problem is that the same sentence may have several
translation, depending on the context.

However, this is not true for a paragraph, since paragraphs are by
definition longer than sentences. That's why the probability to find
exactly the same paragraph in two documents, where the respective contexts
change the meaning is almost null.

Splitting on smaller parts than the sentence would be B<very bad>. It would
be a bit long to explain why here, but interested reader can refer to the
L<Locale::Maketext::TPJ13(3pm)|Locale::Maketext::TPJ13(3pm)> man page
(which comes with the perl documentation), for example. To make short, each
language have its specific syntaxic rules, and there is no way to build
sentences by aggregating parts of sentences working for all existing
languages (or even for the 5 of the 10 most spoken ones, or even less).

=head2 Putting the original as comment along with translation.

At the first glance, gettext don't seem to be adapted to all
translations. For example, if you want to use the translation from your
code, you have to compile it to mo files, and install those files in a
pretty rigid directory tree (the path have to end with
E<lt>localeE<gt>/LC_MESSAGES/E<lt>domainE<gt>.mo). 

For example, it didn't seemed adapted to debconf, the interface all Debian
packages should use for the configuration question of their installation
scripts. In that case, the texts to translate were pretty short (a dozen of
line for each package), and it was impossible to wait for the installation
of a mo file before the use of the text, since these text were precisely
used at pre-installation time.

That's why the debconf developers decided to implement another
solution. They decided that translations could be placed in the same file
than the original, or in separate files (one per language). Before use (i.e.,
at compilation time), all languages had to be placed in the same file.

This is rather appealing. One would even want to do this for xml, for
example. It would look like that:

 <section>
  <title lang="en">My title</title>
  <title lang="fr">Mon titre</title>

  <para>
   <text lang="en">My text.</text>
   <text lang="fr">Mon texte.</text>
  </para>
 </section>

But this approach was so problematic that debconf developers completely
changed their mind and now use a po-based approach. Only the original can
be edited in the file, and the translations should take place in po files
extracted from the master template, and placed back in a compiled template.

What were the encountered problems, which forced developers to change
their mind that way, do you ask? Well, there is quite few problems:

=over

=item * maintainance problems

How will you handle conflicting patches if several translators work on
several languages at the same time?

=item * encoding problems

This solution can work as long as you translate to European language, that
can be feasible, but if it's translated to Korean, Russian and Arab, you're
dead. UTF could be a solution, but there is still some problems with it.

Moreover, such problems are hard to detect (i.e., only Korean speaking
people can see that the encoding of Korean is broken [because of the
Russian translator])

=item * maintainance problems, again

How will you detect changes to the original, which need to be applied to
the translations? 

diff isn't useful here, unless you deploy a pretty heavy infrastructure to
see which original text is translated by which translation (i.e., until you
put some kind of po file in your file ;), and unless there is no big
reorganization. Moreover, diff will show you all changes, not only the
changes to original...

=back

All those troubles are avoided by the use of gettext and the associated
tools. Since you have one file per translation, translators of one language
can't mess with the work of another language. All needed information about
this language is contained in this po file, and all you have to do, as
maintainer, is to copy this file to the right location of your project
tree. Everything is automagic.

=head2 But gettext wasn't designed for that use!

That's true, and documentation translation may benefit some extensions to
the gettext framework (like a flag to mark if the text may be rewrapped or
not, or the diff between new and old translation when an entry is marked
fuzzy by msgmerge), but until now nobody came with a better solution than
it, and the only known alternative is to translate documentation per hand.

=head2 What about the other po-based documentation solution?

As far as I know, there is only two of them: 

=over 

=item poxml

This is the tool developed by KDE people to handle DocBook XML. AFAIK, it
was the first program to extract strings to translate from documentation to
po files, and inject them back after translation.

=item po-debiandoc

This program done by Denis Barbier is a sort of precursor of the po4a sgml
module. As the name says, it handles only the debiandoc dtd.

=back

The main disadvantage of poxml over po-debiandoc and po4a is that lists are
badly handled. Ie, all the list is put in only one string to translate. For
big lists, this makes rather long and indigest chunks. 

The main advantage of po4a over poxml and po-debiandoc is that it
allows/simplifies the add of content which is not a translation. If you
though that the po4a way wasn't practical, don't try the two other programs
;)

=head2 Educating developers about translation

When you try to translate documentation or programs, you face three kind of
problems; linguistics (not everybody speaks two languages), technical
(that's why po4a exists) and relational/human. Not all developers
understand the necessity of translating stuff, and even when good willed,
they ignore most of the time what they should do to help the work of
translators. To counter that, po4a comes with lot of documentation which
can be referred	 to.

Another important point is that each file should begin with a short header
as comment indicating what it is and what it is good for so that
developers know what to do with them when a translator send them for
inclusion in the project.

In the po4a project, translated document are not source files
anymore. Since sgml files are habitually source files, this fact is easy to
forget. Here is the text added by pod-translate:


 |       *****************************************************
 |       *           GENERATED FILE, DO NOT EDIT             * 
 |       * THIS IS NO SOURCE FILE, BUT RESULT OF COMPILATION *
 |       *****************************************************
 |
 | This file was generated by po4a-translate(1) version $VERSION. Do not 
 | store it (in cvs, for example), but store the po file used as source
 | file by po4a-translate. 
 |
 | In fact, consider this as a binary, and the po file as a regular .c file:
 | If the po get lost, keeping this translation up-to-date will be harder ;)

Likewise, gettext's regular po files only need to be copied to the po/
directory. But B<this is not the case of the ones manipulated by po4a>. The
major risk here is that a developer erase the existing translation of his
program with the translation of his documentation. (Both of them can't be
stored in the same po file, because the program needs to install its
translation as mo file while the documentation only use its translation at
compile time). That's why the po files produced by the po-debiandoc module
contain the following header:

 #
 #  ADVISES TO DEVELOPERS:
 #    - you do not need to manually edit POT or PO files.
 #    - this file contains the translation of your debconf templates.
 #      Do not replace the translation of your program with this !!
 #        (or your translators will get very upset)
 #
 #  ADVISES TO TRANSLATORS:
 #    If you are not familiar with the PO format, gettext documentation 
 #     is worth reading, especially sections dedicated to this format.
 #    For example, run:
 #         info -n '(gettext)PO Files'
 #         info -n '(gettext)Header Entry'
 #
 #    Some information specific to po-debconf are available at
 #            /usr/share/doc/po-debconf/README-trans
 #         or http://www.debian.org/intl/l10n/po-debconf/README-trans
 #

=head2 SUMMARY of the advantages of the gettext based approach

=over 2

=item *

The translations are not stored along with the original, which makes
possible to detect if translations become out of date.

=item *

The translations are stored in separate files from each other. This means
that translators for two different languages can update their work at the
same time without headaches for the maintainer. Moreover, one translator
cannot break the encoding of the other languages, since each file have a
clear and unique encoding.

=item *

It is based internally on C<gettext> (but C<po4a> offers a very simple
interface so that you don't need to understand the internals to use it).
That way, we don't have to re-implement the wheel, and because of their
wide use, we can think that these tools are more or less bug free.

=item *

Nothing changed for the end-user (beside the fact translations will
hopefully be better maintained :). The resulting documentation file
distributed is exactly the same.

=item *

No need for translators to learn a new file syntax and their favorite po
file editor (like emacs'po mode, kbabel or gtranslator) will work just fine.

=item * 

Gettext offers simple way to get statistics about what is done, what should
be reviewed and updated, and what is still to do. Some example can be found
at those addresses:

 - http://i18n.kde.org/tools/kbabel/img/previewKonq.png
 - http://www.debian.org/intl/l10n

=back

But everything isn't green, and this approach also have some disadvantages
we have to deal with.

=over 2

=item *

Adding of material isn't really simple. I did my best to keep the addendum
mechanism simple, but...

=item *

You can't adapt the translated text to your preferences, like splitting a
paragraph here, and joining two other ones there. You are limited to
B<translating>. In my mind, that's almost a good thing. If the original
text have some problems, they should be considered as bugs, and get fixed
in the original text, so that all users can benefit from the changes, not
only the ones speaking your language.

=item *

Even if we tried to keep the interface simple, it's still a new tool people
have to learn. To ease this, we should provide ready to use makefiles that
people could put in their project tree. 

One of my dreams would be to integrate somehow po4a to gtranslator or
kbabel. If the user tries to open a sgml file in the program, strings are
automatically extracted, and when you're done, a translated sgml file can
be written to disk. If we make a MS Word (TM) module, we could even sell it
to profesional translators ;)

=back

=head1 Known bugs and feature requests

=head2 Do resynchronize the files on gettextization

That way, we can report all the errors and not only the first one, so that
the user can save them to file and correct several of them at the same
time.

The easiest way to perform that is to write all the types found in original
in a file (one per line), and same thing for translation in another file,
run C<diff> on them, and analyze the result.

=head2 Allow to embed the addendum in po files

One of the advantages of gettext is that all information needed for one
language is concentrated in a unique file, and that the possible error from
the developer are very limited.

To do the same, we should allow translators to put their addendum in the po
file itself, as comment.

=head1 AUTHORS

 Denis Barbier <barbier@linuxfr.org>
 Martin Quinson <martin.quinson@tuxfamily.org>

=cut

LocalWords:  po gettext sgml xml texinfo perl gettextize fr kbabel KDE updatepo
LocalWords:  gtranslator gettextization cvs regexp boundary
LocalWords:  lang TransTractor debconf diff poxml debiandoc LocalWords
LocalWords: Denis barbier linuxfr org Quinson tuxfamily
